Why Your Debug Shows “Failed to write register address”

Because SPD2010 rejects the wrong register (0x2000).
It expects 0x0020 for status and 0x0300 for HDP data.


✅ Fix Plan

Update all register addresses to match Arduino driver:

Status: 0x0020
HDP: 0x0300
Clear INT: 0x0002
CPU Start: 0x0004
Start Touch: 0x0046
Point Mode: 0x0050


Implement ACK + re-arm for Clear INT.
Keep delays and retry logic.






✅ Key Confirmations from Arduino Code


Byte Order

Register: big-endian (high byte first).
Data: little-endian (low byte first).
This matches what we implemented in the patched ESPHome version.



✅ Repeated Start for Reads

They use i2c_master_write_read_device() for reads, which is equivalent to our write_read() approach.



✅ Command Sequences

The Arduino code explicitly handles BIOS/CPU states:

If tic_in_bios → send ClearInt + CpuStart.
If tic_in_cpu → send PointMode + Start + ClearInt.


Our current ESPHome implementation does not handle these states. It only sends the init sequence once during setup().
This could explain why your device still fails after init — it might be stuck in BIOS or CPU mode.



✅ Interrupt Handling

Arduino version clears _interrupt_flag and uses INT pin to trigger reads.
ESPHome version polls periodically (no ISR). This is okay but less efficient.



✅ HDP Done-Check Loop

Arduino code loops until HDP packets are fully consumed.
Our ESPHome code reads only once and assumes done. This might cause partial data issues.